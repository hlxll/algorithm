<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>算法笔记</h1>
    <h2>算法复杂度</h2>
    <span>
        算法复杂度，计算复杂度时候，相乘的常数可以省略，加的常数可以省略，比如3n^2+1复杂度是f（n^2）
    </span>
    <h2>线性表</h2>
    <span>
        具有线一样的性质,是有限的，有两种存储结构，
        顺序存储和链式存储
        <h3>顺序存储</h3>
        顺序存储就是物理地址依次存储，存储空间：起始位置，最大存储容量，当前长度，找第i个元素，直接用索引就可以
        优缺点：无需为表中元素之间的逻辑关系增加额外存储空间，可以快速存取表中任意位置元素，插入删除需要移动大量元素，当线性表长度变化比较大，难以确定存储空间的容量，容易产生空间碎片
        <h3>链式存储</h3>
        一个数据存储有数据域存储数据和指针域存储后继位置的域
        <h4>单链表</h4>
            第一个数据是头指针，最后一个数据指向null，无论链表是否为空，头指针不为空，单链表获取第i个元素位置，需要从第一个往后找
        <span>
            单链表插入：第i个插入，声明一个节点p，初始化j为1，当j'<'1,就遍历链表
            单链表删除：就是把前继节点的指针绕过，指向后继节点，p->next = p->next->next,p->next就是要删除的
        </span>
        <span>
            创建单链表
            顺序存储结构的线性表的整体表创建，可以用数组的初始化直观理解，所占用空间大小和位置是不需要预先分配划定的，可以根据系统的情况和实际需求即时生成
            建立单链表：头插法，先让新节点的next指向头节点之后，然后让表头的next指向新节点
            尾插法，直接
        </span>
        <span>
            删除单链表，是将p指针下一个指针域存为q，，然后删除p数据，再把q赋给p
        </span>
        <h3>
            存储分配方式，时间性能，
            单链表不需要分配空间，只要有就可以分配
            若线性表需要频繁查找，很少进行插入和删除操作，适合用顺序存储结构
            若频繁插入删除，采用单链表结构
            事先知道大致长度，适合用顺序存储结构
        </h3>
        <span>
            静态链表的优缺点，插入删除只需要修改游标，不用大量移动元素，没有解决连续存储分配带来的表长难以确定的缺点
        </span>
    </span>
    <span>
        <h1>单链表小结</h1>
        <span>
            找到单链表的中间节点，单链表只能顺序查找，知道前面一个数据，通过指针域确定下一个数据
            <span>
                先遍历一遍，确定长度L，再遍历一遍找到L/2
            </span>
            <span>
                指定两个指针，一个是跨越1个遍历min，另外一个是两倍max，那两倍的max到终点，min就到中间了
            </span>
        </span>
        
    </span>
    <span>
        <span>
            循环链表
        </span>
        <span>
            单链表的终节点指向头结点，
            判断单链表是否有环，设置两个点，q和p，一个每次走一步，另一个每次走两步，再次相遇就是有环
            方法二： q每次走一步，p每次从头开始走到q所在的地方，q走了几步会记录下来，如果和p走的不想等了，就是有环
        </span>
    </span>
    <span>
        <span>约瑟夫问题</span>
        <span>
            每次跳3个，然后删除，直到最后剩下2个，用循环链表处理
        </span>
    </span>
    <span>
        <span>魔术师发牌问题和拉丁方阵问题</span>
        循环链表实现魔术师发牌：第一次翻一张，是1，第二次翻第二张是2，前面的放下面，第三次翻第三张，前面的放下面，
        共翻13张，实现一个摆放顺序，可以实现这样的翻牌
        实现拉丁方阵：第一行从第一个开始按顺序排，第二行从第二个开始按顺序排，第三行从第三个开始排。
        实现nxn方阵，每一行只有1到n的一个，每一列只有1到n的一个
    </span>
    <span></span>
    <span></span>
    <span></span>
    <span></span>
    <span></span>
    <span></span>
    <span></span>
    <span></span>
    <span></span>
    <span></span>
</body>
</html>